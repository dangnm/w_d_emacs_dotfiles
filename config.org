* Installation
** Setup Emacs dotfiles
ln -sf ~/w_d_emacs_dotfiles/config.org ~/.doom.d/config.org
** Enable org file config
Go to ~/.doom.d/init.el and uncomment literate
** Rebuild config
SPC h r r OR M-x doom/reload

* Helpers
** File path helpers
   #+BEGIN_SRC emacs-lisp
     (defun s/show-buffer-file-path ()
       "Show the full path to the current file in the minibuffer."
       (interactive)
       (let ((file-name (buffer-file-name)))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/show-buffer-project-path ()
       "Show the full path to the current project in the minibuffer."
       (interactive)
       (let ((project-path (projectile-project-root)))
         (if project-path
             (progn
               (message project-path)
               (kill-new project-path))
           (error "Buffer not visiting a project"))))

     (defun s/show-buffer-file-name ()
       "Show the full path to the current file in the minibuffer."
       (interactive)
       (let ((file-name (file-name-nondirectory(buffer-file-name))))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/show-buffer-file-name-base ()
       "Show current file name base in the minibuffer."
       (interactive)
       (let ((file-name (file-name-base(buffer-file-name))))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/file-path-with-line ()
       "Retrieve the file path of the current buffer, including line number.

     Returns:
       - A string containing the file path in case of success.
       - `nil' in case the current buffer does not have a directory."
       (when-let (file-path (buffer-file-name))
         (concat file-path ":" (number-to-string (line-number-at-pos)))))

     (defun w/show-buffer-file-path-with-line ()
       "Show current file name base in the minibuffer."
       (interactive)
       (let ((file-name (w/file-path-with-line)))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))
   #+END_SRC

   #+RESULTS:
   : w/show-buffer-file-path-with-line

** Text edit helpers
   #+BEGIN_SRC emacs-lisp
     (defun toggle-camelcase-underscores ()
       "Toggle between camelcase and underscore notation for the symbol at point."
       (interactive)
       (save-excursion
         (let* ((bounds (bounds-of-thing-at-point 'symbol))
                (start (car bounds))
                (end (cdr bounds))
                (currently-using-underscores-p (progn (goto-char start)
                                                      (re-search-forward "_" end t))))
           (if currently-using-underscores-p
               (progn
                 (upcase-initials-region start end)
                 (replace-string "_" "" nil start end)
                 (downcase-region start (1+ start)))
             (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ start) end)
             (downcase-region start (cdr (bounds-of-thing-at-point 'symbol)))))))

     (defun toggle-camelcase-motion ()
       (interactive)
       (if (get 'camelcase-motion-toggle-flag 'state)
           (progn
             (message "Disabled camelcase motion")
             (subword-mode'-1)
             (put 'camelcase-motion-toggle-flag'state nil))
         (progn
           (message "Enabled camelcase motion")
           (subword-mode)
           (put 'camelcase-motion-toggle-flag 'state t))
         )
       )
   #+END_SRC

   #+RESULTS:
   : toggle-camelcase-motion

* Key bindings
** Windows binding
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "Split window right" "w/" (lambda () (interactive) (split-window-right) (other-window 1)))
#+END_SRC

** Jump binding
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "jump" "j" nil)
(map! :leader :desc "go to word" "jw" #'evil-avy-goto-word-or-subword-1)
#+END_SRC
