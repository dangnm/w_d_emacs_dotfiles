* Installation
** Setup Emacs dotfiles
ln -sf ~/w_d_emacs_dotfiles/config.org ~/.doom.d/config.org
** Enable org file config
Go to ~/.doom.d/init.el and uncomment literate
** Rebuild config
SPC h r r OR M-x doom/reload

* Helpers
** File path helpers
   #+BEGIN_SRC emacs-lisp
     (defun s/show-buffer-file-path ()
       "Show the full path to the current file in the minibuffer."
       (interactive)
       (let ((file-name (buffer-file-name)))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/show-buffer-project-path ()
       "Show the full path to the current project in the minibuffer."
       (interactive)
       (let ((project-path (projectile-project-root)))
         (if project-path
             (progn
               (message project-path)
               (kill-new project-path))
           (error "Buffer not visiting a project"))))

     (defun s/show-buffer-file-name ()
       "Show the full path to the current file in the minibuffer."
       (interactive)
       (let ((file-name (file-name-nondirectory(buffer-file-name))))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/show-buffer-file-name-base ()
       "Show current file name base in the minibuffer."
       (interactive)
       (let ((file-name (file-name-base(buffer-file-name))))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))

     (defun w/file-path-with-line ()
       "Retrieve the file path of the current buffer, including line number.

     Returns:
       - A string containing the file path in case of success.
       - `nil' in case the current buffer does not have a directory."
       (when-let (file-path (buffer-file-name))
         (concat file-path ":" (number-to-string (line-number-at-pos)))))

     (defun w/show-buffer-file-path-with-line ()
       "Show current file name base in the minibuffer."
       (interactive)
       (let ((file-name (w/file-path-with-line)))
         (if file-name
             (progn
               (message file-name)
               (kill-new file-name))
           (error "Buffer not visiting a file"))))
   #+END_SRC

   #+RESULTS:
   : w/show-buffer-file-path-with-line

** Text edit helpers
   #+BEGIN_SRC emacs-lisp
     (defun toggle-camelcase-underscores ()
       "Toggle between camelcase and underscore notation for the symbol at point."
       (interactive)
       (save-excursion
         (let* ((bounds (bounds-of-thing-at-point 'symbol))
                (start (car bounds))
                (end (cdr bounds))
                (currently-using-underscores-p (progn (goto-char start)
                                                      (re-search-forward "_" end t))))
           (if currently-using-underscores-p
               (progn
                 (upcase-initials-region start end)
                 (replace-string "_" "" nil start end)
                 (downcase-region start (1+ start)))
             (replace-regexp "\\([A-Z]\\)" "_\\1" nil (1+ start) end)
             (downcase-region start (cdr (bounds-of-thing-at-point 'symbol)))))))

     (defun toggle-camelcase-motion ()
       (interactive)
       (if (get 'camelcase-motion-toggle-flag 'state)
           (progn
             (message "Disabled camelcase motion")
             (subword-mode'-1)
             (put 'camelcase-motion-toggle-flag'state nil))
         (progn
           (message "Enabled camelcase motion")
           (subword-mode)
           (put 'camelcase-motion-toggle-flag 'state t))
         )
       )
   #+END_SRC

   #+RESULTS:
   : toggle-camelcase-motion

* Key bindings
** Commons
#+BEGIN_SRC emacs-lisp
(setq w/secondary-leader-key ",")
#+END_SRC
** Windows binding
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "Split window right" "w/" (lambda () (interactive) (split-window-right) (other-window 1)))
#+END_SRC

** Jump binding
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "jump" "j" nil)
(map! :leader :desc "dired jump" "jd" #'magit-dired-jump)
(map! :leader :desc "goto char" "jj" #'evil-avy-goto-char)
(map! :leader :desc "go to char 2" "jJ" #'evil-avy-goto-char-2)
(map! :leader :desc "goto line" "jl" #'evil-avy-goto-line)
(map! :leader :desc "go to word" "jw" #'evil-avy-goto-word-or-subword-1)
#+END_SRC

** M-x command
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "M-x command" "SPC" #'counsel-M-x)
#+END_SRC

** Dired secondary leader key
#+BEGIN_SRC emacs-lisp
       (general-define-key
        :states '(normal visual insert emacs)
        :prefix w/secondary-leader-key
        :non-normal-prefix "M-n"
        :keymaps 'dired-mode-map
        "," 'dired-up-directory
        "u" '(dired-unmark :which-key "unmark(u)")
        "m" '(dired-mark :which-key "mark(m)")
        "r" '(revert-buffer-no-confirm :which-key "refresh(r)")
        "j" 'dired-next-subdir
        "k" 'dired-prev-subdir
        "h" 'w/dired-go-to-home-folder
        "F" 'find-name-dired
                                             ;Actions
        "a" '(:ignore t :which-key "Actions")
        "af" '(:ignore t :which-key "Files")
        "afn" '(find-file :which-key "Create file")
        "afN" 'dired-create-directory
        "afr" '(dired-do-rename :which-key "Rename(Shift + r)")
        "afd" '(dired-do-delete :which-key "Delete(Shift + d)")
        "ae" '(:ignore t :which-key "Edit")
        "aex" '(dired-copy-paste-do-cut :which-key "Cut")
        "aec" '(dired-copy-paste-do-copy :which-key "Copy")
        "aep" '(dired-copy-paste-do-paste :which-key "Paste")
                                             ;Toggle
        "T" '(:ignore t :which-key "toggles")
        "Td" 'dired-hide-details-mode
        )
     (defun w/dired-go-to-home-folder ()
       (interactive)
       (if (not(string= "~/" default-directory))
           (find-alternate-file "~/")
         )
       )

     (defun dired-copy-paste-do-cut ()
       "In dired-mode, cut a file/dir on current line or all marked file/dir(s)."
       (interactive)
       (setq dired-copy-paste-stored-file-list (dired-get-marked-files)
             dired-copy-paste-func 'rename-file)
       (message
        (format "%S is/are cut."dired-copy-paste-stored-file-list)))


     (defun dired-copy-paste-do-copy ()
       "In dired-mode, copy a file/dir on current line or all marked file/dir(s)."
       (interactive)
       (setq dired-copy-paste-stored-file-list (dired-get-marked-files)
             dired-copy-paste-func 'copy-file)
       (message
        (format "%S is/are copied."dired-copy-paste-stored-file-list)))


     (defun dired-copy-paste-do-paste ()
       "In dired-mode, paste cut/copied file/dir(s) into current directory."
       (interactive)
       (let ((stored-file-list nil))
         (dolist (stored-file dired-copy-paste-stored-file-list)
           (condition-case nil
               (progn
                 (funcall dired-copy-paste-func stored-file (dired-current-directory) 1)
                 (push stored-file stored-file-list))
             (error nil)))
         (if (eq dired-copy-paste-func 'rename-file)
             (setq dired-copy-paste-stored-file-list nil
                   dired-copy-paste-func nil))
         (revert-buffer)
         (message
          (format "%d file/dir(s) pasted into current directory." (length stored-file-list)))))
#+END_SRC
